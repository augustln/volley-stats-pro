<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Volley Pro Stats</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Lucide Icons for a clean icon set -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <!-- Google Fonts for typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --background-start-rgb: 15, 23, 42; /* slate-900 */
            --glass-color: rgba(30, 41, 59, 0.7); /* slate-800 with opacity */
            --border-color: rgba(255, 255, 255, 0.1);
            --accent-color: #8b5cf6; /* violet-500 */
            --text-color: #e2e8f0; /* slate-200 */
            --text-muted-color: #94a3b8; /* slate-400 */
        }

        html, body {
            overscroll-behavior: none;
            position: fixed;
            inset: 0;
            overflow: hidden;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: rgb(var(--background-start-rgb));
            background-image: radial-gradient(ellipse 80% 80% at 50% -20%,rgba(120,119,198,0.3),hsla(0,0%,100%,0));
            color: var(--text-color);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .app-container {
            height: 100vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        #app {
            padding-bottom: 10rem;
        }

        .glass-card {
            background-color: var(--glass-color);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
        }

        .glass-button {
            background-color: var(--glass-color);
            border: 1px solid var(--border-color);
            transition: all 0.2s ease-in-out;
        }
        .glass-button:hover { background-color: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.2); }

        .tab { position: relative; color: var(--text-muted-color); }
        .tab-active { color: var(--text-color); }
        .tab-active::after { content: ''; position: absolute; bottom: -1px; left: 0; right: 0; height: 2px; background-color: var(--accent-color); border-radius: 2px; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background-color: rgba(128,128,128,0.2); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background-color: rgba(128,128,128,0.3); }

        .rank-badge { display: inline-flex; align-items: center; padding: 0.25rem 0.75rem; border-radius: 9999px; font-weight: 600; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; white-space: nowrap; }
        .rank-master { background-color: #fda4af; color: #881337; }
        .rank-diamond { background-color: #d8b4fe; color: #581c87; }
        .rank-platinum { background-color: #6ee7b7; color: #064e3b; }
        .rank-gold { background-color: #fcd34d; color: #78350f; }
        .rank-silver { background-color: #cbd5e1; color: #1e293b; }
        .rank-bronze { background-color: #fdba74; color: #7c2d12; }

        @keyframes glowing {
            0% { box-shadow: 0 0 3px #fcd34d; }
            50% { box-shadow: 0 0 10px #fbbf24, 0 0 5px #fbbf24; }
            100% { box-shadow: 0 0 3px #fcd34d; }
        }
        .peak-skill-glow { animation: glowing 2s infinite; border: 1px solid #fbbf24; }

        .sticky-col {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            z-index: 10;
        }
        #player-stats-table-head .sticky-col {
            background-color: var(--glass-color);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        #player-stats-table-body .sticky-col {
            background: rgb(var(--background-start-rgb));
        }
    </style>
</head>
<body>

    <div id="app-container" class="app-container">
        <div id="app" class="max-w-7xl mx-auto p-4 md:p-6 lg:p-8">
            <header class="flex flex-col md:flex-row justify-between items-center mb-6 md:mb-8">
                <div class="text-center md:text-left mb-4 md:mb-0">
                    <h1 class="text-3xl sm:text-4xl font-extrabold">Volley Pro Stats</h1>
                    <p class="text-muted-color">The ultimate tool for volleyball analytics</p>
                </div>
                <div id="admin-status" class="flex items-center gap-2 text-sm glass-card px-3 py-2"></div>
            </header>

            <div class="mb-6 border-b border-slate-700/50">
                <nav id="tabs" class="flex flex-nowrap overflow-x-auto -mb-px text-sm font-medium">
                    <a href="#" data-tab="leaderboard" class="tab py-4 px-3 md:px-4">Leaderboard</a>
                    <a href="#" data-tab="player_stats" class="tab py-4 px-3 md:px-4">Player Stats</a>
                    <a href="#" data-tab="weekly_review" class="tab py-4 px-3 md:px-4">Weekly Review</a>
                    <a href="#" data-tab="head2head" class="tab py-4 px-3 md:px-4">H2H</a>
                    <a href="#" data-tab="records" class="tab py-4 px-3 md:px-4">Records</a>
                    <a href="#" data-tab="guide" class="tab py-4 px-3 md:px-4">System Guide</a>
                    <a href="#" data-tab="admin" class="tab py-4 px-3 md:px-4">Admin</a>
                </nav>
            </div>

            <main id="content-wrapper"></main>

            <div id="modal-backdrop" class="fixed inset-0 bg-black/70 hidden items-center justify-center p-4 z-50">
                <div id="modal-content" class="glass-card p-4 sm:p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto"></div>
            </div>
        </div>
    </div>

    <script>
        const app = {
            state: {
                sourceData: { matches: [], playerDetails: {} },
                processedData: null,
                activeTab: 'leaderboard',
                playerStatsSort: { column: 'skill', direction: 'desc' },
                adminSecret: null,
                showInactive: false,
                availableWeeks: [],
                currentWeek: null,
                hasUnsavedChanges: false,
            },

            hexToRgba(hex, alpha = 1) {
                if (!hex) return `rgba(203, 213, 225, ${alpha})`; // default to silver
                const hexVal = hex.startsWith('#') ? hex.slice(1) : hex;
                if (hexVal.length !== 6) return `rgba(203, 213, 225, ${alpha})`;
                const [r, g, b] = hexVal.match(/\w\w/g).map(x => parseInt(x, 16));
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            },

            // --- INITIALIZATION & APP START ---
            async init() {
                this.renderAdminStatus();
                this.setupTabListener();
                this.setupDelegatedListeners();

                document.getElementById('content-wrapper').innerHTML = this.templates.loader('Loading match data...');
                try {
                    const response = await fetch('/api/get_initial_data');
                    if (!response.ok) throw new Error('Failed to load initial data.');
                    this.state.sourceData = await response.json();

                    if (this.state.sourceData.matches.length > 0) {
                        this.state.activeTab = 'leaderboard';
                        await this.processData(false);
                    } else {
                        this.state.activeTab = 'admin';
                    }
                } catch (error) {
                    console.error("Initialization Error:", error);
                    this.state.activeTab = 'admin';
                } finally {
                    this.activateTab(this.state.activeTab);
                    lucide.createIcons();
                }
            },

            // --- DATA MANAGEMENT (CLIENT-SIDE) ---
            async processData(showLoading = true) {
                if (showLoading) {
                   document.getElementById('content-wrapper').innerHTML = this.templates.loader('Calculating stats...');
                }
                try {
                    const response = await fetch('/api/process_data', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(this.state.sourceData)
                    });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    this.state.processedData = await response.json();

                    if (this.state.processedData && this.state.processedData.weeklyData) {
                        this.state.availableWeeks = Object.keys(this.state.processedData.weeklyData)
                            .map(Number).sort((a, b) => b - a);

                        if (!this.state.currentWeek || !this.state.availableWeeks.includes(this.state.currentWeek)) {
                            this.state.currentWeek = this.state.availableWeeks[0] || null;
                        }
                    } else {
                        this.state.availableWeeks = [];
                        this.state.currentWeek = null;
                    }
                    this.activateTab(this.state.activeTab);
                } catch (error) {
                    console.error("Failed to process data:", error);
                    document.getElementById('content-wrapper').innerHTML = this.templates.error('Could not process data. Ensure the backend is running.');
                }
            },

            downloadData() {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.state.sourceData, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", `volley-stats-pro-${new Date().toISOString().split('T')[0]}.json`);
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
                this.state.hasUnsavedChanges = false;
                this.activateTab('admin');
            },

            // --- EVENT LISTENERS (REBUILT FOR RELIABILITY) ---
            setupDelegatedListeners() {
                const appEl = document.getElementById('app');
                appEl.addEventListener('click', (e) => {
                    const playerLink = e.target.closest('a[data-player-name]');
                    const matchLink = e.target.closest('[data-match-id]');
                    const backButton = e.target.closest('#back-to-main');

                    if (playerLink) {
                        e.preventDefault();
                        this.renderPlayerDetail(playerLink.dataset.playerName);
                        return;
                    }
                    if (matchLink) {
                        e.preventDefault();
                        this.showMatchModal(matchLink.dataset.matchId);
                        return;
                    }
                    if (backButton) {
                        e.preventDefault();
                        this.activateTab(backButton.dataset.originTab);
                        return;
                    }
                });
            },

            setupTabListener() {
                document.getElementById('tabs').addEventListener('click', (e) => {
                    e.preventDefault();
                    const tabLink = e.target.closest('[data-tab]');
                    if (tabLink) this.activateTab(tabLink.dataset.tab);
                });
            },

            attachEventListeners(viewName) {
                if (viewName === 'admin') {
                    document.getElementById('admin-unlock-form')?.addEventListener('submit', e => {
                        e.preventDefault();
                        this.state.adminSecret = e.target.elements.adminSecret.value;
                        this.renderAdminStatus();
                        this.activateTab('admin');
                    });
                    document.getElementById('add-match-form')?.addEventListener('submit', e => { e.preventDefault(); this.addMatch(); });
                    document.getElementById('download-data-btn')?.addEventListener('click', () => this.downloadData());
                }
                if (viewName === 'leaderboard') {
                    document.getElementById('toggle-inactive')?.addEventListener('change', e => {
                        this.state.showInactive = e.target.checked;
                        this.activateTab('leaderboard');
                    });
                }
                 if (viewName === 'weekly_review') {
                    document.getElementById('week-selector')?.addEventListener('change', e => {
                        this.state.currentWeek = parseInt(e.target.value);
                        this.activateTab('weekly_review');
                    });
                }
                if (viewName === 'head2head') {
                    document.getElementById('h2h-player1')?.addEventListener('change', () => this.updateHead2Head());
                    document.getElementById('h2h-player2')?.addEventListener('change', () => this.updateHead2Head());
                    this.updateHead2Head();
                }
                 if (viewName === 'player_stats') {
                    document.querySelectorAll('.sortable-header').forEach(el => {
                        el.addEventListener('click', () => this.sortPlayerStats(el.dataset.sortBy));
                    });
                }
                if (viewName === 'playerDetail') {
                    document.getElementById('edit-player-btn')?.addEventListener('click', (e) => this.showEditPlayerModal(e.currentTarget.dataset.playerName));
                }
            },

            // --- VIEW MANAGEMENT & RENDERING ---
            activateTab(tabName) {
                this.state.activeTab = tabName;
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('tab-active'));
                document.querySelector(`.tab[data-tab="${tabName}"]`)?.classList.add('tab-active');

                if (!this.state.processedData && !['guide', 'admin'].includes(tabName)) {
                    document.getElementById('content-wrapper').innerHTML = this.templates.noDataLoaded();
                    lucide.createIcons();
                    return;
                }

                const contentWrapper = document.getElementById('content-wrapper');
                const renderMap = {
                    leaderboard: this.renderLeaderboard,
                    player_stats: this.renderPlayerStatsTable,
                    weekly_review: this.renderWeeklyReview,
                    head2head: this.renderHead2Head,
                    records: this.renderRecords,
                    guide: this.templates.guide,
                    admin: this.renderAdmin,
                };

                try {
                    contentWrapper.innerHTML = renderMap[tabName].call(this);
                    this.attachEventListeners(tabName);
                    lucide.createIcons();
                } catch (error) {
                     console.error(`Failed to render tab "${tabName}":`, error);
                     contentWrapper.innerHTML = this.templates.error(`An error occurred while rendering this tab.`);
                }
            },

            renderPlayerDetail(playerName) {
                if (!this.state.processedData.playerStats[playerName]) return;
                const contentWrapper = document.getElementById('content-wrapper');
                const stats = this.state.processedData.playerStats[playerName];
                const details = this.state.processedData.playerDetails[playerName] || {};
                const rank = this.getRankInfo(stats.skill);
                const isPeak = stats.skill.toFixed(2) >= stats.peakSkill.toFixed(2);
                const displayName = `${stats.name} ${details.lastName || ''} ${details.number ? `#${details.number}`: ''}`.trim();
                const recentMatchesHtml = this.renderPlayerMatchHistory(playerName);
                // --- FIX: Use .call(this, ...) to ensure the template has the correct 'this' context ---
                contentWrapper.innerHTML = this.templates.playerDetail.call(this, playerName, displayName, stats, rank, isPeak, this.state.activeTab, recentMatchesHtml);
                this.renderEloChart(playerName);
                this.attachEventListeners('playerDetail');
                lucide.createIcons();
            },

            // --- TAB-SPECIFIC RENDER FUNCTIONS ---
            renderAdmin() {
                return this.templates.adminWrapper(this.state.adminSecret, this.state.sourceData.matches.length > 0, this.state.hasUnsavedChanges);
            },

            renderLeaderboard() {
                const { leaderboard, playerStats, totalMatches, playerDetails } = this.state.processedData;
                let playersToDisplay = this.state.showInactive ? leaderboard : leaderboard.filter(p => (totalMatches - 1 - playerStats[p.name].last_played) < 15);
                let listHtml = '';
                let lastSkill = -9999;
                let rank = 0;
                playersToDisplay.forEach((player, index) => {
                    const currentSkill = player.skill.toFixed(3);
                    if (currentSkill !== lastSkill) rank = index + 1;
                    lastSkill = currentSkill;
                    const stats = playerStats[player.name];
                    const rankInfo = this.getRankInfo(player.skill);
                    const details = playerDetails[player.name] || {};
                    const displayName = `${player.name} ${details.abbrev ? `(${details.abbrev})` : ''}`;
                    listHtml += this.templates.leaderboardRow(player, displayName, rank, rankInfo, (totalMatches - 1 - stats.last_played) >= 15);
                });
                if (playersToDisplay.length === 0) listHtml = `<li class="text-center py-8 text-slate-400">No active players found.</li>`;
                return this.templates.leaderboardWrapper(listHtml, this.state.showInactive);
            },

            renderPlayerStatsTable(justBody = false) {
                const stats = Object.values(this.state.processedData.playerStats);
                const { column, direction } = this.state.playerStatsSort;
                stats.sort((a, b) => {
                    let valA = a[column], valB = b[column];
                    if (column === 'winRate') { valA = parseFloat(a.winRate); valB = parseFloat(b.winRate); }
                    else if (column === 'name') { return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA); }
                    else if (column === 'currentStreak') { valA = a.currentStreak.type === 'W' ? a.currentStreak.count : -a.currentStreak.count; valB = b.currentStreak.type === 'W' ? b.currentStreak.count : -b.currentStreak.count; }
                    valA = parseFloat(valA) || -Infinity; valB = parseFloat(valB) || -Infinity;
                    if (valA < valB) return direction === 'asc' ? -1 : 1;
                    if (valA > valB) return direction === 'asc' ? 1 : -1;
                    return a.name.localeCompare(b.name);
                });
                const tableRows = stats.map(p => this.templates.playerStatsRow(p, this.getWinRateColor(p.winRate))).join('');
                if (justBody) {
                    document.getElementById('player-stats-table-body').innerHTML = tableRows;
                    document.querySelectorAll('#player-stats-table-head .sortable-header').forEach(el => {
                        el.classList.remove('sort-asc', 'sort-desc');
                        if (el.dataset.sortBy === column) el.classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');
                    });
                    return;
                }
                return this.templates.playerStatsWrapper(tableRows, column, direction);
            },

            renderWeeklyReview() {
                if(this.state.availableWeeks.length === 0) return this.templates.noWeeklyData();
                const weekData = this.state.processedData.weeklyData[this.state.currentWeek];
                const weekMatches = this.state.processedData.matches
                    .map((match, index) => ({ ...match, originalIndex: index }))
                    .filter(m => m.week === this.state.currentWeek).reverse();
                return this.templates.weeklyReviewWrapper.call(this, weekData, weekMatches, this.state.availableWeeks, this.state.currentWeek);
            },

            renderHead2Head() {
                const playerNames = Object.keys(this.state.processedData.playerStats).sort();
                return this.templates.head2headWrapper(playerNames);
            },

            renderRecords() {
                const { duos, rivalries, superlatives, matches, playerStats } = this.state.processedData;
                const playerRecords = [
                    { title: 'Highest Peak Skill', key: 'peakSkill', format: v => v.toFixed(2), color: 'text-amber-300' },
                    { title: 'Most Wins', key: 'wins', color: 'text-green-300' },
                    { title: 'Most Matches Played', key: 'total', color: 'text-slate-300' },
                    { title: 'Highest Win Rate', key: 'winRate', format: v => `${parseFloat(v).toFixed(1)}%`, minGames: 10, color: 'text-sky-300' },
                    { title: 'Longest Win Streak', key: 'longestWinStreak', format: v => `${v}W`, color: 'text-rose-300' },
                    { title: 'Longest Current Streak', key: 'currentStreak', format: v => `${v.count}${v.type}`, color: 'text-yellow-300', sort: 'streak' },
                    { title: 'Best Clutch Rate', key: 'clutchRate', format: v => `${v.toFixed(1)}%`, minGames: 10, color: 'text-orange-300' },
                    { title: 'Biggest Climber (10)', key: 'skillChangeLast10', format: v => `${v > 0 ? '+' : ''}${v.toFixed(2)}`, minGames: 10, color: 'text-teal-300', sort: 'form' },
                ];
                return this.templates.recordsWrapper.call(this, duos, rivalries, superlatives, matches, playerStats, playerRecords);
            },

            // --- HELPERS & MODALS ---
            sortPlayerStats(newColumn) {
                const { playerStatsSort } = this.state;
                if (playerStatsSort.column === newColumn) {
                    playerStatsSort.direction = playerStatsSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    playerStatsSort.column = newColumn;
                    playerStatsSort.direction = ['name'].includes(newColumn) ? 'asc' : 'desc';
                }
                this.renderPlayerStatsTable(true);
            },

            async updateHead2Head() {
                const p1Name = document.getElementById('h2h-player1').value;
                const p2Name = document.getElementById('h2h-player2').value;
                const resultsDiv = document.getElementById('h2h-results');
                if (!p1Name || !p2Name || p1Name === p2Name) {
                    resultsDiv.innerHTML = '<p class="text-center text-muted-color mt-8">Select two different players to compare.</p>';
                    return;
                }
                const stats1 = this.state.processedData.playerStats[p1Name];
                const stats2 = this.state.processedData.playerStats[p2Name];
                const rank1 = this.getRankInfo(stats1.skill);
                const rank2 = this.getRankInfo(stats2.skill);

                try {
                    const response = await fetch('/api/head2head', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            player1: p1Name,
                            player2: p2Name,
                            matches: this.state.sourceData.matches
                        })
                    });
                    if (!response.ok) throw new Error('H2H calculation failed.');
                    const h2hData = await response.json();
                    resultsDiv.innerHTML = this.templates.head2headResults(stats1, stats2, h2hData.player1_wins, h2hData.player2_wins, h2hData.total_matches, rank1, rank2);
                } catch (error) {
                    console.error('H2H Error:', error);
                    resultsDiv.innerHTML = '<p class="text-center text-red-400 mt-8">Could not calculate Head-to-Head stats.</p>';
                }
            },

            renderEloChart(playerName) {
                const ctx = document.getElementById('elo-chart')?.getContext('2d');
                if (!ctx) return;
                const fullHistory = this.state.processedData.history[playerName];
                const playerStats = this.state.processedData.playerStats[playerName];
                const skillData = fullHistory.map(h => h.mu - 3 * h.sigma);
                const peakSkill = playerStats.peakSkill;

                if (window.eloChartInstance) window.eloChartInstance.destroy();

                const minSkill = Math.min(...skillData, 0);
                const maxSkill = Math.max(...skillData);
                const range = maxSkill - minSkill;
                const buffer = Math.max(2, range * 0.15);
                const yMin = Math.floor(minSkill - buffer);
                const yMax = Math.ceil(maxSkill + buffer);

                const customAnnotationsPlugin = {
                    id: 'customAnnotationsPlugin',
                    afterDatasetsDraw: (chart) => {
                        const { ctx, chartArea: { top, bottom, left, right }, scales: { y } } = chart;
                        ctx.save();

                        // --- Peak Skill Line and Label ---
                        const peakY = y.getPixelForValue(peakSkill);
                        if (peakY >= top && peakY <= bottom) {
                            ctx.beginPath();
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([4, 4]);
                            ctx.moveTo(left, peakY);
                            ctx.lineTo(right, peakY);
                            ctx.stroke();
                            ctx.setLineDash([]); // Reset dash

                            ctx.font = '600 10px Inter, sans-serif';
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                            ctx.textAlign = 'right';
                            ctx.textBaseline = 'bottom';
                            ctx.fillText(`Peak Skill • ${peakSkill.toFixed(2)}`, right, peakY - 4);
                        }

                        // --- Rank Tier Lines and Labels ---
                        const tiers = this.getRankInfo().tiers.slice(1); // Exclude Bronze base
                        tiers.forEach(tier => {
                            if (tier.min > y.min && tier.min < y.max) {
                                const yPos = y.getPixelForValue(tier.min);
                                ctx.beginPath();
                                ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                                ctx.lineWidth = 1;
                                ctx.moveTo(left, yPos);
                                ctx.lineTo(right, yPos);
                                ctx.stroke();

                                ctx.font = '600 10px Inter, sans-serif';
                                ctx.fillStyle = tier.color;
                                ctx.textAlign = 'left';
                                ctx.textBaseline = 'bottom';
                                ctx.fillText(`${tier.min} • ${tier.name}`, left + 4, yPos - 4);
                            }
                        });

                        ctx.restore();
                    }
                }

                window.eloChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: fullHistory.map((h,i) => i),
                        datasets: [{
                            data: skillData,
                            fill: true,
                            tension: 0.1,
                            pointRadius: 0, // No points
                            pointHoverRadius: 5,
                            stepped: false, // Back to smooth line
                            segment: {
                                borderColor: ctx => this.getRankInfo(ctx.p1.raw)?.color || '#cbd5e1',
                                backgroundColor: ctx => this.hexToRgba(this.getRankInfo(ctx.p1.raw)?.color, 0.2), // More visible fill
                            },
                        }]
                    },
                    options: {
                        animation: { duration: 0 }, maintainAspectRatio: false,
                        scales: { x: { display: false }, y: { min: yMin, max: yMax, ticks: { color: '#94a3b8', font: { size: 10 } }, grid: { color: 'rgba(128,128,128, 0.1)' } } },
                        interaction: { mode: 'index', intersect: false },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                enabled: true,
                                mode: 'index',
                                intersect: false,
                                displayColors: false,
                                backgroundColor: 'rgba(15, 23, 42, 0.8)',
                                titleFont: { size: 0 },
                                bodyFont: { size: 12, weight: 'bold' },
                                padding: 8,
                                callbacks: {
                                    label: (context) => `Skill: ${context.raw.toFixed(2)}`
                                }
                            }
                        }
                    },
                    plugins: [customAnnotationsPlugin], // Removed the full background plugin
                });
            },

            renderAdminStatus() {
                const statusDiv = document.getElementById('admin-status');
                statusDiv.innerHTML = this.state.adminSecret
                    ? `<i data-lucide="shield-check" class="h-4 w-4 text-green-400"></i><span class="text-green-400">Admin Mode</span>`
                    : `<i data-lucide="eye" class="h-4 w-4 text-slate-400"></i><span class="text-slate-400">Read-Only Mode</span>`;
                lucide.createIcons();
            },

            getRankInfo(skill) {
                const tiers = [
                    { name: 'Master',   min: 25, class: 'rank-master', color: '#fda4af' },
                    { name: 'Diamond',  min: 20, class: 'rank-diamond', color: '#d8b4fe'},
                    { name: 'Platinum', min: 15, class: 'rank-platinum', color: '#6ee7b7'},
                    { name: 'Gold',     min: 10, class: 'rank-gold', color: '#fcd34d'},
                    { name: 'Silver',   min: 5, class: 'rank-silver', color: '#cbd5e1'},
                    { name: 'Bronze',   min: -Infinity, class: 'rank-bronze', color: '#fdba74' }
                ];
                // If skill is passed, return the specific tier. If not, return all tiers.
                return skill !== undefined ? tiers.find(t => skill >= t.min) : { tiers };
            },

            getWinRateColor(winRate) {
                const wr = parseFloat(winRate);
                if (wr > 60) return 'text-green-400';
                if (wr < 40) return 'text-red-400';
                return 'text-slate-300';
            },

            renderPlayerMatchHistory(playerName) {
                const { matches, history } = this.state.processedData;
                const playerMatchIds = history[playerName].slice(1).map(h => h.match_id);
                return playerMatchIds.slice(-10).reverse().map(matchId => {
                    const match = matches[matchId];
                    const playerHistory = history[playerName];
                    const historyEntry = playerHistory.find(h => h.match_id == matchId);
                    if (!historyEntry) return ''; // Safeguard
                    const historyIndex = playerHistory.indexOf(historyEntry);
                    const preSkill = playerHistory[historyIndex-1].mu - 3 * playerHistory[historyIndex-1].sigma;
                    const postSkill = historyEntry.mu - 3 * historyEntry.sigma;
                    const skillChange = postSkill - preSkill;
                    const isTeamA = match.teamA.includes(playerName);
                    const won = (isTeamA && match.scoreA > match.scoreB) || (!isTeamA && match.scoreB > match.scoreA);
                    return this.templates.playerMatchHistoryRow(match, matchId, won, skillChange, playerName);
                }).join('');
            },

            showModal(content) {
                document.body.style.overflow = 'hidden';
                document.getElementById('modal-content').innerHTML = content;
                const backdrop = document.getElementById('modal-backdrop');
                backdrop.classList.remove('hidden');
                backdrop.classList.add('flex');
                backdrop.addEventListener('click', () => this.closeModal(), { once: true });
                document.getElementById('modal-content').addEventListener('click', e => e.stopPropagation());
                document.querySelectorAll('.close-modal-btn').forEach(btn =>
                    btn.addEventListener('click', () => this.closeModal(), { once: true })
                );
                lucide.createIcons();
            },

            closeModal() {
                document.body.style.overflow = '';
                const backdrop = document.getElementById('modal-backdrop');
                backdrop.classList.add('hidden');
                backdrop.classList.remove('flex');
                document.getElementById('modal-content').innerHTML = '';
            },

            async showMatchModal(matchId) {
                const match = this.state.processedData.matches[matchId];
                this.showModal(this.templates.loader('Loading match details...'));

                try {
                    const response = await fetch(`/api/match_details/${matchId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            matches: this.state.sourceData.matches,
                            history: this.state.processedData.history
                        })
                    });
                    if (!response.ok) throw new Error('Match detail calculation failed.');
                    const details = await response.json();

                    const modalContent = this.templates.matchModal(match, details.team_a_changes, details.team_b_changes, details.win_prob_a, matchId);
                    document.getElementById('modal-content').innerHTML = modalContent;
                    lucide.createIcons();
                } catch (error) {
                    console.error('Match Modal Error:', error);
                    document.getElementById('modal-content').innerHTML = this.templates.error('Could not load match details.');
                }
            },

            showEditPlayerModal(playerName) {
                const details = this.state.sourceData.playerDetails[playerName] || {};
                this.showModal(this.templates.editPlayerModal(playerName, details));

                document.getElementById('edit-player-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    const form = e.target;
                    const oldName = playerName;
                    const newName = form.elements.newName.value.trim();
                    const newDetails = {
                        lastName: form.elements.lastName.value.trim(),
                        abbrev: form.elements.abbrev.value.trim().toUpperCase(),
                        number: form.elements.number.value.trim(),
                    };

                    if (oldName !== newName) {
                        if (this.state.sourceData.playerDetails[newName]) {
                            alert(`Player '${newName}' already exists.`);
                            return;
                        }
                        // Rename in matches
                        this.state.sourceData.matches.forEach(match => {
                            match.teamA = match.teamA.map(p => p === oldName ? newName : p);
                            match.teamB = match.teamB.map(p => p === oldName ? newName : p);
                        });
                        // Rename in playerDetails
                        this.state.sourceData.playerDetails[newName] = newDetails;
                        delete this.state.sourceData.playerDetails[oldName];
                    } else {
                        this.state.sourceData.playerDetails[newName] = newDetails;
                    }

                    this.state.hasUnsavedChanges = true;
                    this.closeModal();
                    this.processData(false);
                });
            },

            addMatch() {
                const form = document.getElementById('add-match-form');
                const parsePlayers = str => str.split(',').map(p => p.trim().replace(/\s+/g, ' ')).filter(Boolean);
                const newMatch = {
                    teamA: parsePlayers(form.elements.teamA.value),
                    teamB: parsePlayers(form.elements.teamB.value),
                    scoreA: parseInt(form.elements.scoreA.value),
                    scoreB: parseInt(form.elements.scoreB.value),
                    ts: Date.now()
                };
                if (newMatch.teamA.length === 0 || newMatch.teamB.length === 0 || isNaN(newMatch.scoreA) || isNaN(newMatch.scoreB)) {
                    alert('Please fill all fields correctly.'); return;
                }
                if (new Set([...newMatch.teamA, ...newMatch.teamB]).size !== newMatch.teamA.length + newMatch.teamB.length) {
                    alert("A player cannot be on both teams."); return;
                }

                [...newMatch.teamA, ...newMatch.teamB].forEach(player => {
                    if (!this.state.sourceData.playerDetails[player]) {
                        this.state.sourceData.playerDetails[player] = {};
                    }
                });

                this.state.sourceData.matches.push(newMatch);
                this.state.hasUnsavedChanges = true;
                form.reset();
                this.state.activeTab = 'weekly_review';
                this.processData(false);
            },

            // --- AWARD FORMATTING HELPERS ---
            formatAwardNames(data, valueFormatter) {
                if (!data || !data.names || data.names.length === 0) return '<p class="text-muted-color">N/A</p>';
                let namesHtml;
                if (data.names.length > 1) {
                    namesHtml = `<ul class="font-bold text-lg space-y-1">${data.names.map(name =>
                        `<li><a href="#" class="truncate hover:underline" data-player-name="${name}">${name}</a></li>`
                    ).join('')}</ul>`;
                } else {
                    const name = data.names[0];
                    namesHtml = `<p class="font-bold text-lg truncate"><a href="#" class="hover:underline" data-player-name="${name}">${name}</a></p>`;
                }
                const valueHtml = `<p class="font-semibold">${valueFormatter(data.value)}</p>`;
                return `${namesHtml}${valueHtml}`;
            },
            formatDuoAwards(data) {
                if (!data || !data.players_list || data.players_list.length === 0) return '<p class="text-muted-color">N/A</p>';
                const duosHtml = data.players_list.map(duo => `<p class="font-bold text-lg">${duo.map(p => `<a href="#" class="hover:underline" data-player-name="${p}">${p}</a>`).join(' & ')}</p>`).join('');
                return `${duosHtml}<p class="font-semibold">${data.wins} Wins Together</p>`;
            },
            formatClutcherAward(data) {
                if (!data || !data.names || data.names.length === 0) return '<p class="text-muted-color">No qualifiers (min 3 attempts)</p>';
                let namesHtml;
                if (data.names.length > 1) {
                    namesHtml = `<ul class="font-bold text-lg space-y-1">${data.names.map(name =>
                        `<li><a href="#" class="truncate hover:underline" data-player-name="${name}">${name}</a></li>`
                    ).join('')}</ul>`;
                } else {
                    const name = data.names[0];
                    namesHtml = `<p class="font-bold text-lg truncate"><a href="#" class="hover:underline" data-player-name="${name}">${name}</a></p>`;
                }
                const valueHtml = `<p class="font-semibold">${data.value.toFixed(0)}% Clutch Win Rate (${data.attempts} att.)</p>`;
                return `${namesHtml}${valueHtml}`;
            },

            // --- HTML TEMPLATES ---
            templates: {
                loader: message => `<div class="text-center py-20"><div class="mx-auto h-12 w-12 border-4 border-t-violet-500 border-slate-600 rounded-full animate-spin"></div><p class="mt-4 text-muted-color">${message}</p></div>`,
                error: message => `<div class="glass-card p-8 text-center"><i data-lucide="alert-triangle" class="h-12 w-12 mx-auto text-red-400 mb-4"></i><h3 class="text-xl font-bold">An Error Occurred</h3><p class="text-muted-color mt-2">${message}</p></div>`,
                noDataLoaded: () => `<div class="glass-card p-8 text-center"><i data-lucide="database-zap" class="h-12 w-12 mx-auto text-slate-500 mb-4"></i><h2 class="text-2xl font-bold mb-2">No Match Data Found</h2><p class="text-muted-color">The <code class="bg-slate-800/50 p-1 rounded">volley-pro-matches.json</code> file could not be loaded or is empty. Go to the <strong class="text-violet-400">Admin</strong> tab to manage data.</p></div>`,
                noWeeklyData: () => `<div class="glass-card p-8 text-center"><i data-lucide="calendar-x" class="h-12 w-12 mx-auto text-slate-500 mb-4"></i><h2 class="text-2xl font-bold mb-2">No Weekly Data</h2><p class="text-muted-color">Play some matches to see weekly summaries here.</p></div>`,
                adminWrapper: (isAdmin, isDataLoaded, hasUnsavedChanges) => {
                    if (!isAdmin) {
                        return `<div class="glass-card p-8 text-center max-w-md mx-auto"><i data-lucide="lock" class="h-12 w-12 mx-auto text-slate-500 mb-4"></i><h2 class="text-2xl font-bold mb-2">Admin Locked</h2><p class="text-muted-color mb-6">Enter the admin secret to add new matches, edit players, and download the updated data file.</p><form id="admin-unlock-form" class="flex items-center gap-2"><input type="password" name="adminSecret" class="w-full bg-slate-800/50 border border-slate-600 rounded-md px-4 py-2 text-center focus:ring-2 focus:ring-violet-500 focus:outline-none" placeholder="Enter admin secret..."><button type="submit" class="bg-violet-600 text-white rounded-md p-2 font-semibold hover:bg-violet-700 transition"><i data-lucide="arrow-right" class="h-6 w-6"></i></button></form></div>`;
                    }
                    let unsavedWarning = hasUnsavedChanges
                        ? `<div class="bg-yellow-500/10 text-yellow-300 text-sm p-3 rounded-lg flex items-center gap-3"><i data-lucide="alert-triangle" class="h-5 w-5"></i><div>You have unsaved changes. Download your data file to save them.</div></div>`
                        : '';
                    return `
                     <div class="max-w-xl mx-auto space-y-8">
                        <div class="glass-card p-4 sm:p-6">
                             <h2 class="text-2xl font-bold mb-4">Data Management</h2>
                             <p class="text-muted-color text-sm mb-4">Remember to download your data to save any changes like new matches. This will create an updated <code class="bg-slate-800/50 p-1 rounded">.json</code> file for your repository.</p>
                            <div class="flex">
                               <button id="download-data-btn" class="flex-1 w-full glass-button rounded-md py-3 font-semibold flex items-center justify-center gap-2 ${!isDataLoaded ? 'opacity-50 cursor-not-allowed' : ''}" ${!isDataLoaded ? 'disabled' : ''}>
                                   <i data-lucide="download" class="w-5 h-5"></i> Download Data File
                               </button>
                            </div>
                            ${unsavedWarning}
                        </div>
                        <div class="glass-card p-4 sm:p-6">
                            <h2 class="text-2xl font-bold mb-4">Add a New Match</h2>
                            <form id="add-match-form" class="space-y-4">
                                <div><label class="block font-medium mb-1 text-slate-300">Team A</label><textarea name="teamA" rows="2" class="w-full bg-slate-800/50 border border-slate-600 rounded-md p-2" placeholder="Comma-separated names..."></textarea></div>
                                <div><label class="block font-medium mb-1 text-slate-300">Team B</label><textarea name="teamB" rows="2" class="w-full bg-slate-800/50 border border-slate-600 rounded-md p-2" placeholder="Comma-separated names..."></textarea></div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div><label class="block font-medium mb-1 text-slate-300">Score A</label><input type="number" name="scoreA" class="w-full bg-slate-800/50 border border-slate-600 rounded-md p-2 text-center text-lg font-bold"></div>
                                    <div><label class="block font-medium mb-1 text-slate-300">Score B</label><input type="number" name="scoreB" class="w-full bg-slate-800/50 border border-slate-600 rounded-md p-2 text-center text-lg font-bold"></div>
                                </div>
                                <button type="submit" class="w-full bg-violet-600 text-white rounded-md py-3 font-semibold hover:bg-violet-700 transition">Record Match</button>
                            </form>
                        </div>
                    </div>`
                },
                leaderboardWrapper: (listHtml, showInactiveChecked) => `<div><div class="flex justify-between items-center mb-4"><h2 class="text-2xl font-bold">Player Leaderboard</h2><label class="flex items-center text-sm cursor-pointer text-slate-300"><input type="checkbox" id="toggle-inactive" class="mr-2 h-4 w-4 rounded border-slate-600 bg-slate-700 text-violet-500 focus:ring-violet-600" ${showInactiveChecked ? 'checked' : ''}>Show Inactive</label></div><div class="glass-card"><ul id="leaderboard-list">${listHtml}</ul></div></div>`,
                leaderboardRow: (player, displayName, rank, rankInfo, isInactive) => `
                    <li class="flex items-center justify-between p-3 sm:p-4 border-b border-slate-700/50 last:border-b-0 hover:bg-white/5 transition-colors ${isInactive ? 'opacity-50' : ''}">
                        <div class="flex items-center gap-3 sm:gap-4">
                            <span class="text-lg font-bold text-muted-color w-6 text-center">${rank}</span>
                             <div>
                                <a href="#" data-player-name="${player.name}" class="font-bold text-base sm:text-lg hover:underline">${displayName}</a>
                                <p class="text-sm text-muted-color">Skill: ${player.skill.toFixed(2)}</p>
                            </div>
                        </div>
                        <span class="rank-badge ${rankInfo.class}">${rankInfo.name}</span>
                    </li>`,
                playerStatsWrapper: (tableRows, sortCol, sortDir) => `
                    <div>
                        <h2 class="text-2xl font-bold mb-4">Detailed Player Stats</h2>
                        <div class="glass-card overflow-x-auto">
                            <table class="w-full text-left min-w-[700px]">
                                <thead id="player-stats-table-head" class="border-b border-slate-700/50">
                                    <tr>
                                        ${['name', 'skill', 'peakSkill', 'winRate', 'total', 'wins', 'losses', 'longestWinStreak', 'currentStreak'].map(col => {
                                            const labels = {name: 'Player', skill: 'Skill', peakSkill: 'Peak', winRate: 'Win %', total: 'Played', wins: 'Wins', losses: 'Losses', longestWinStreak: 'Best Streak', currentStreak: 'Streak'};
                                            const thClass = col === 'name' ? 'sticky-col' : '';
                                            return `<th class="p-3 text-xs font-semibold text-muted-color uppercase tracking-wider ${thClass}">
                                                <span class="sortable-header ${sortCol === col ? (sortDir === 'asc' ? 'sort-asc' : 'sort-desc') : ''}" data-sort-by="${col}">${labels[col]}</span>
                                            </th>`
                                        }).join('')}
                                    </tr>
                                </thead>
                                <tbody id="player-stats-table-body">${tableRows}</tbody>
                            </table>
                        </div>
                    </div>`,
                playerStatsRow: (p, winRateColor) => {
                    const streakColor = p.currentStreak.type === 'W' ? 'text-green-400' : 'text-red-400';
                    return `
                    <tr class="border-b border-slate-700/50 last:border-b-0 hover:bg-white/5 transition-colors">
                        <td class="p-3 font-bold whitespace-nowrap sticky-col"><a href="#" data-player-name="${p.name}" class="hover:underline">${p.name}</a></td>
                        <td class="p-3 font-semibold text-violet-300">${p.skill.toFixed(2)}</td>
                        <td class="p-3">${p.peakSkill.toFixed(2)}</td>
                        <td class="p-3 font-semibold ${winRateColor}">${p.winRate}%</td>
                        <td class="p-3">${p.total}</td>
                        <td class="p-3 text-green-400">${p.wins}</td>
                        <td class="p-3 text-red-400">${p.losses}</td>
                        <td class="p-3">${p.longestWinStreak}W</td>
                        <td class="p-3 font-semibold ${streakColor}">${p.currentStreak.count > 0 ? `${p.currentStreak.count}${p.currentStreak.type}` : '-'}</td>
                    </tr>`
                },
                recordsWrapper: function(duos, rivalries, superlatives, matches, playerStats, playerRecords) {
                    const recordListTemplate = (record) => {
                        const topPlayers = Object.values(playerStats)
                            .filter(p => !record.minGames || p.total >= record.minGames)
                            .sort((a, b) => {
                                if (record.sort === 'streak') {
                                    const valA = a.currentStreak.type === 'W' ? a.currentStreak.count : -a.currentStreak.count;
                                    const valB = b.currentStreak.type === 'W' ? b.currentStreak.count : -b.currentStreak.count;
                                    return valB - valA;
                                }
                                if (record.sort === 'form') return b.skillChangeLast10 - a.skillChangeLast10;
                                const valA = record.key === 'winRate' ? parseFloat(a[record.key]) : a[record.key];
                                const valB = record.key === 'winRate' ? parseFloat(b[record.key]) : b[record.key];
                                return (parseFloat(valB) || 0) - (parseFloat(valA) || 0);
                            }).slice(0, 5);
                        let listHtml = '';
                        let lastValue = null;
                        let rank = 0;
                        topPlayers.forEach((p, i) => {
                            const value = p[record.key];
                            let comparableValue;
                            if (record.sort === 'streak') { comparableValue = (value.type === 'W' ? value.count : -value.count); }
                            else if (typeof value === 'number') { comparableValue = value.toFixed(3); }
                            else { comparableValue = parseFloat(value).toFixed(3); }
                            if (comparableValue !== lastValue) rank = i + 1;
                            lastValue = comparableValue;
                            listHtml += `<li class="flex justify-between items-center"><a href="#" data-player-name="${p.name}" class="font-semibold truncate hover:underline"><span class="inline-block w-5">${rank}.</span> ${p.name}</a><span class="font-bold ${record.color} flex-shrink-0 ml-2">${record.format ? record.format(value) : value}</span></li>`;
                        });
                        return `<div class="bg-slate-800/50 p-4 rounded-lg"><h3 class="font-bold text-lg mb-2">${record.title}</h3><ul class="space-y-2 text-sm">${listHtml}</ul></div>`;
                    };
                    return `
                    <div id="records-content" class="space-y-8">
                         <div class="glass-card p-4 sm:p-6">
                            <h2 class="text-2xl font-bold mb-4">Season Records</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                ${[
                                    { superlative: superlatives.upset, title: 'Biggest Upset', color: 'text-violet-400', line: `Winner had a <strong>${superlatives.upset?.prob ? (superlatives.upset.prob * 100).toFixed(1) : 'N/A'}%</strong> chance to win.` },
                                    { superlative: superlatives.dominant, title: 'Most Dominant Win', color: 'text-amber-400', line: `Won by a margin of <strong>${superlatives.dominant?.margin ?? 'N/A'}</strong> points.`},
                                    { superlative: superlatives.highCaliber, title: 'Highest Caliber Match', color: 'text-sky-400', line: `Average player skill was <strong>${superlatives.highCaliber?.avgSkill ? superlatives.highCaliber.avgSkill.toFixed(2) : 'N/A'}</strong>.`},
                                    { superlative: superlatives.best_performance, title: 'Best Single-Match Performance', color: 'text-rose-400', line: `<a href="#" class="font-bold hover:underline" data-player-name="${superlatives.best_performance?.player}">${superlatives.best_performance?.player}</a> gained <strong>+${superlatives.best_performance?.skill_gain ? superlatives.best_performance.skill_gain.toFixed(2) : 'N/A'}</strong> skill.` }
                                ].map(item => {
                                    const match = item.superlative?.match_id !== undefined ? matches[item.superlative.match_id] : null;
                                    return match ? `<div data-match-id="${item.superlative.match_id}" class="bg-slate-800/50 p-4 rounded-lg hover:bg-slate-800/80 cursor-pointer transition"><h3 class="font-bold text-lg ${item.color}">${item.title}</h3><p class="text-sm text-muted-color mb-2">${item.line}</p><div class="text-xs"><p>${match.teamA.join(', ')} vs ${match.teamB.join(', ')}</p><p class="font-bold text-lg">${match.scoreA} - ${match.scoreB}</p></div></div>` : `<div class="bg-slate-800/50 p-4 rounded-lg"><h3 class="font-bold text-lg text-slate-500">${item.title}</h3><p class="text-sm text-slate-600">No matches yet.</p></div>`;
                                }).join('')}
                            </div>
                        </div>
                        <div class="glass-card p-4 sm:p-6"><h2 class="text-2xl font-bold mb-4">Player Records</h2><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">${playerRecords.map(record => recordListTemplate(record)).join('')}</div></div>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                           ${[
                               { title: 'Top Duos', data: duos },
                               { title: 'Biggest Rivalries', data: rivalries }
                           ].map(table => `<div class="glass-card"><div class="p-4 border-b border-slate-700/50"><h2 class="text-xl font-bold">${table.title}</h2><p class="text-sm text-muted-color">Min. 5 matches played.</p></div><div class="overflow-x-auto"><table class="w-full text-left"><thead><tr class="text-xs text-muted-color uppercase"><th class="p-3">Players</th><th class="p-3">Record</th><th class="p-3">${table.title === 'Top Duos' ? 'Win %' : 'Total'}</th></tr></thead><tbody>${(table.data || []).length > 0 ? table.data.map(d => table.title === 'Top Duos' ? `<tr><td class="p-3 font-semibold">${d.players.map(p => `<a href="#" data-player-name="${p}" class="hover:underline">${p}</a>`).join(' & ')}</td><td class="p-3">${d.wins}-${d.total-d.wins}</td><td class="p-3 font-bold ${this.getWinRateColor( (d.wins/d.total)*100 )}">${((d.wins/d.total)*100).toFixed(1)}%</td></tr>` : `<tr><td class="p-3 font-semibold">${d.players[0]} vs ${d.players[1]}</td><td class="p-3 font-bold text-violet-400">${d.p1_wins} - ${d.p2_wins}</td><td class="p-3">${d.total}</td></tr>`).join('') : '<tr><td colspan="3" class="p-4 text-center text-muted-color">Not enough data.</td></tr>'}</tbody></table></div></div>`).join('')}
                        </div>
                    </div>`},
                 weeklyReviewWrapper: function(weekData, weekMatches, availableWeeks, currentWeek) {
                    const seasonStartDate = new Date('2025-09-01T00:00:00Z');
                    const weekStartDate = new Date(seasonStartDate.getTime());
                    weekStartDate.setDate(weekStartDate.getDate() + (currentWeek - 1) * 7);
                    const weekEndDate = new Date(weekStartDate.getTime());
                    weekEndDate.setDate(weekEndDate.getDate() + 6);
                    const formatDate = (date) => date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                    return `
                    <div class="space-y-8">
                        <div>
                            <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-4">
                                <div>
                                    <h2 class="text-2xl font-bold">Weekly Review</h2>
                                    <p class="text-muted-color">Summary for ${formatDate(weekStartDate)} - ${formatDate(weekEndDate)}</p>
                                </div>
                                <select id="week-selector" class="w-full mt-2 sm:mt-0 sm:w-auto p-2 border border-slate-600 rounded-md bg-slate-800/50 focus:ring-2 focus:ring-violet-500 focus:outline-none">
                                    ${availableWeeks.map(w => `<option value="${w}" ${w === currentWeek ? 'selected' : ''}>Week ${w}</option>`).join('')}
                                </select>
                            </div>
                            ${this.templates.weeklyReviewContent.call(this, weekData, weekMatches)}
                        </div>
                    </div>`
                },
                weeklyReviewContent: function(weekData, weekMatches) {
                     const awards = [
                        { icon: 'trending-up', color: 'text-green-400', title: 'Top Performer', data: weekData.topPerformer, format: (data) => this.formatAwardNames(data, v => `Skill Gained: +${v.toFixed(2)}`) },
                        { icon: 'flame', color: 'text-orange-400', title: 'Most Active', data: weekData.mostActive, format: (data) => this.formatAwardNames(data, v => `${v} Matches Played`) },
                        { icon: 'crown', color: 'text-amber-400', title: 'Most Wins', data: weekData.mostWins, format: (data) => this.formatAwardNames(data, v => `${v} Wins`) },
                        { icon: 'users', color: 'text-sky-400', title: 'Best Duo(s)', data: weekData.bestDuo, format: (data) => this.formatDuoAwards(data) },
                        { icon: 'diff', color: 'text-teal-400', title: 'Best Point Differential', data: weekData.bestPointDiff, format: (data) => this.formatAwardNames(data, v => `Net Points: +${v}`) },
                        { icon: 'shield-check', color: 'text-violet-400', title: 'The Ice Man', data: weekData.weeklyClutcher, format: (data) => this.formatClutcherAward(data) },
                        { icon: 'trending-down', color: 'text-red-400', title: 'Biggest Bottler', data: weekData.biggestBottler, format: (data) => this.formatAwardNames(data, v => `Skill Lost: ${v.toFixed(2)}`) },
                        { icon: 'shield-off', color: 'text-rose-400', title: 'Most Points Conceded', data: weekData.worstPointDiff, format: (data) => this.formatAwardNames(data, v => `Net Points: ${v}`) },
                    ];
                    let leaderboardHtml = '<p class="text-muted-color text-center py-4">No ranked players this week.</p>';
                    if (weekData.leaderboard && weekData.leaderboard.length > 0) {
                        let leaderboardHtmlParts = []; let lastSkill = -9999; let rank = 0;
                        weekData.leaderboard.slice(0, 10).forEach((player, index) => {
                            const currentSkill = player.skill.toFixed(3);
                            if (currentSkill !== lastSkill) rank = index + 1;
                            lastSkill = currentSkill;
                            const rankInfo = this.getRankInfo(player.skill);
                            leaderboardHtmlParts.push(`<li class="rounded-md hover:bg-slate-900/80"><a href="#" data-player-name="${player.name}" class="flex items-center justify-between p-2"><div class="flex items-center gap-3"><span class="font-bold text-muted-color w-5 text-center">${rank}</span><p class="font-semibold">${player.name}</p></div><div class="flex items-center gap-2"><span class="font-semibold text-sm">${player.skill.toFixed(2)}</span><span class="rank-badge ${rankInfo.class}">${rankInfo.name}</span></div></a></li>`);
                        });
                        leaderboardHtml = `<ul class="space-y-2">${leaderboardHtmlParts.join('')}</ul>`;
                    }
                    const matchesHtml = weekMatches.length > 0 ? weekMatches.map(match => this.templates.matchCard(match, match.originalIndex)).join('') : '<p class="text-muted-color text-center py-8 col-span-full">No matches were played this week.</p>';
                    return `
                        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                            <div class="lg:col-span-1 space-y-6">
                                <div class="glass-card p-4"><h3 class="font-bold mb-2 text-center">End of Week Leaderboard</h3>${leaderboardHtml}</div>
                            </div>
                            <div class="lg:col-span-2">
                                <h3 class="text-xl font-bold mb-4">Weekly Awards</h3>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
                                    ${awards.map(award => `<div class="bg-slate-800/50 p-4 rounded-lg flex items-start gap-3 sm:gap-4"><i data-lucide="${award.icon}" class="h-7 w-7 sm:h-8 sm:w-8 ${award.color} flex-shrink-0 mt-1"></i><div><p class="text-sm text-muted-color">${award.title}</p>${award.format(award.data)}</div></div>`).join('')}
                                </div>
                                <h3 class="text-xl font-bold mb-4">Matches This Week</h3>
                                <div class="grid grid-cols-1 xl:grid-cols-2 gap-4 max-h-[60vh] overflow-y-auto pr-2">${matchesHtml}</div>
                            </div>
                        </div>`
                },
                head2headWrapper: playerNames => `<div class="glass-card p-4 sm:p-6"><h2 class="text-2xl font-bold mb-4">Head-to-Head Comparison</h2><div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">${[1,2].map(n => `<div><label class="block text-sm font-medium mb-1 text-slate-300">Player ${n}</label><select id="h2h-player${n}" class="w-full p-2 border border-slate-600 rounded-md bg-slate-800/50"><option value="">Select player...</option>${playerNames.map(name => `<option value="${name}">${name}</option>`).join('')}</select></div>`).join('')}</div><div id="h2h-results"><p class="text-center text-muted-color mt-8">Select two different players to compare.</p></div></div>`,
                head2headResults: (s1, s2, p1Wins, p2Wins, total, r1, r2) => {
                    const compare = (v1, v2, higherIsBetter = true) => {
                        const val1 = parseFloat(v1) || 0, val2 = parseFloat(v2) || 0;
                        if (Math.abs(val1 - val2) < 0.01) return ['text-slate-400', 'text-slate-400'];
                        const p1Better = higherIsBetter ? val1 > val2 : val1 < val2;
                        return p1Better ? ['text-green-400 font-bold', 'text-red-400'] : ['text-red-400', 'text-green-400 font-bold'];
                    };
                    const compareStreak = (st1, st2) => {
                        const v1 = st1.type === 'W' ? st1.count : -st1.count;
                        const v2 = st2.type === 'W' ? st2.count : -st2.count;
                        return compare(v1, v2);
                    };
                    const c = {
                        skill: compare(s1.skill, s2.skill), peak: compare(s1.peakSkill, s2.peakSkill),
                        winRate: compare(s1.winRate, s2.winRate), streak: compare(s1.longestWinStreak, s2.longestWinStreak),
                        current: compareStreak(s1.currentStreak, s2.currentStreak),
                        clutch: compare(s1.clutchRate, s2.clutchRate),
                    };
                    const h2hRecord = total > 0 ? `<div class="bg-slate-900/50 p-4 rounded-lg inline-block"><p class="text-4xl font-bold"><span class="${p1Wins > p2Wins ? 'text-green-400' : p1Wins < p2Wins ? 'text-red-400' : 'text-slate-400'}">${p1Wins}</span> - <span class="${p2Wins > p1Wins ? 'text-green-400' : p2Wins < p1Wins ? 'text-red-400' : 'text-slate-400'}">${p2Wins}</span></p><p class="text-sm text-muted-color">in ${total} matches</p></div>` : `<div class="bg-slate-900/50 p-4 rounded-lg"><p class="text-muted-color">No matches found against each other.</p></div>`;
                    return `<div class="space-y-6 mt-8"><div class="text-center"><h3 class="text-xl font-semibold mb-2">Direct Confrontation</h3>${h2hRecord}</div><div class="overflow-x-auto"><table class="w-full text-center">
                        <thead class="border-b-2 border-slate-700/50">
                            <tr class="text-lg font-bold">
                                <th class="p-3"><div>${s1.name}</div><div class="text-xs font-normal mt-1"><span class="rank-badge ${r1.class}">${r1.name}</span></div></th>
                                <th class="text-sm font-semibold text-muted-color w-1/3 p-3">Stat</th>
                                <th class="p-3"><div>${s2.name}</div><div class="text-xs font-normal mt-1"><span class="rank-badge ${r2.class}">${r2.name}</span></div></th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-slate-700/50">
                        ${Object.entries({
                            Skill: { v1: s1.skill.toFixed(2), v2: s2.skill.toFixed(2), comp: c.skill },
                            "Peak Skill": { v1: s1.peakSkill.toFixed(2), v2: s2.peakSkill.toFixed(2), comp: c.peak },
                            "Win Rate": { v1: `${s1.winRate}%`, v2: `${s2.winRate}%`, comp: c.winRate },
                            "Clutch Rate": { v1: `${s1.clutchRate.toFixed(1)}%`, v2: `${s2.clutchRate.toFixed(1)}%`, comp: c.clutch },
                            "Record": { v1: `${s1.wins}-${s1.losses}`, v2: `${s2.wins}-${s2.losses}`, comp:['text-slate-400', 'text-slate-400']},
                            "Best Streak": { v1: `${s1.longestWinStreak}W`, v2: `${s2.longestWinStreak}W`, comp: c.streak },
                            "Current Streak": { v1: s1.currentStreak.count > 0 ? `${s1.currentStreak.count}${s1.currentStreak.type}` : '-', v2: s2.currentStreak.count > 0 ? `${s2.currentStreak.count}${s2.currentStreak.type}` : '-', comp: c.current }
                        }).map(([key, val]) => `<tr><td class="p-3 ${val.comp[0]}">${val.v1}</td><td class="p-3 font-semibold">${key}</td><td class="p-3 ${val.comp[1]}">${val.v2}</td></tr>`).join('')}
                    </tbody></table></div></div>`;
                },
                matchCard: (match, matchId) => `
                    <div class="glass-card p-4 hover:border-slate-600 transition cursor-pointer" data-match-id="${matchId}">
                        <div class="flex justify-between items-start mb-2">
                            <div>
                                 <p class="text-xs text-muted-color font-bold">MATCH #${matchId + 1}</p>
                                <p class="font-extrabold text-2xl tracking-tight">${match.scoreA} - ${match.scoreB}</p>
                                <p class="text-xs text-muted-color">${new Date(match.ts).toLocaleDateString()}</p>
                            </div>
                            <i data-lucide="swords" class="h-5 w-5 text-muted-color"></i>
                        </div>
                        <div class="grid grid-cols-2 gap-3 text-xs">
                            <div class="p-2 rounded ${match.scoreA > match.scoreB ? 'bg-green-500/10' : 'bg-slate-800/30'}"><p class="font-bold mb-1 truncate ${match.scoreA > match.scoreB ? 'text-green-300' : ''}">Team A</p><p class="text-muted-color">${match.teamA.join(', ')}</p></div>
                            <div class="p-2 rounded ${match.scoreB > match.scoreA ? 'bg-green-500/10' : 'bg-slate-800/30'}"><p class="font-bold mb-1 truncate ${match.scoreB > match.scoreA ? 'text-green-300' : ''}">Team B</p><p class="text-muted-color">${match.teamB.join(', ')}</p></div>
                        </div>
                    </div>`,
                guide: () => `<div class="grid grid-cols-1 lg:grid-cols-2 gap-8"><div class="glass-card p-4 sm:p-6 space-y-4"><h2 class="text-2xl font-bold">Ranking System Guide</h2><p class="text-muted-color">This app uses the <strong>TrueSkill</strong> algorithm. It tracks a player's skill (μ) and the system's confidence in that skill (σ).</p><p class="text-muted-color">To create a wider, more intuitive spread of ranks, this app uses the conservative skill estimate, calculated as <code class="bg-slate-800/50 p-1 rounded">μ - 3σ</code>. This value provides a clear separation between players of different tiers.</p><p class="text-muted-color">Your rating changes based on the match outcome, the skill of your teammates, and the skill of your opponents. Beating a team of highly-skilled players will earn you more points than beating a team of lower-skilled players.</p></div><div class="glass-card p-4 sm:p-6"><h2 class="text-2xl font-bold mb-4">Skill Tiers (Based on μ - 3σ)</h2><ul class="space-y-3">${[{ name: 'Master', skill: '25+', class: 'rank-master'},{ name: 'Diamond', skill: '20 - 24.99', class: 'rank-diamond'},{ name: 'Platinum', skill: '15 - 19.99', class: 'rank-platinum'},{ name: 'Gold', skill: '10 - 14.99', class: 'rank-gold'},{ name: 'Silver', skill: '5 - 9.99', class: 'rank-silver'},{ name: 'Bronze', skill: '< 5', class: 'rank-bronze'}].map(tier => `<li class="flex items-center justify-between p-2 bg-slate-800/50 rounded-md"><span class="rank-badge ${tier.class}">${tier.name}</span><span class="font-semibold">${tier.skill}</span></li>`).join('')}</ul></div></div>`,
                // --- FIX: Converted to a function to correctly handle 'this' context ---
                playerDetail: function(playerName, displayName, stats, rank, isPeak, originTab, recentMatchesHtml) {
                    return `<div class="glass-card p-4 sm:p-6 max-w-5xl mx-auto">
                        <div class="flex justify-between items-start mb-4">
                            <button id="back-to-main" data-origin-tab="${originTab}" class="flex items-center gap-2 text-sm text-violet-400 hover:underline"><i data-lucide="arrow-left" class="h-4 w-4"></i> Back</button>
                            ${this.state.adminSecret ? `<button id="edit-player-btn" data-player-name="${playerName}" class="flex items-center gap-2 text-sm glass-button rounded-md py-1 px-3"><i data-lucide="edit-3" class="h-4 w-4"></i> Edit</button>` : ''}
                        </div>
                        <div class="flex flex-wrap items-center gap-4 mb-6">
                            <h2 class="text-3xl font-bold">${displayName}</h2>
                            <span class="rank-badge ${rank.class}">${rank.name}</span>
                        </div>
                        <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-6 gap-4 text-center mb-8">
                            ${Object.entries({
                                Skill: stats.skill.toFixed(2),
                                "Peak Skill": {value: stats.peakSkill.toFixed(2), glow: isPeak},
                                "Win Rate": `${stats.winRate}%`,
                                Record: `${stats.wins}-${stats.losses}`,
                                "Best Streak": `${stats.longestWinStreak}W`,
                                "Current Streak": { value: `${stats.currentStreak.count > 0 ? `${stats.currentStreak.count}${stats.currentStreak.type}`: '-'}`, color: stats.currentStreak.type === 'W' ? 'text-green-400' : 'text-red-400'}
                            }).map(([label, data]) => {
                                const value = typeof data === 'object' ? data.value : data;
                                const glowClass = data.glow ? 'peak-skill-glow' : '';
                                const colorClass = data.color || '';
                                return `<div class="bg-slate-800/50 p-3 rounded-lg ${glowClass}"><p class="text-xs text-muted-color uppercase">${label}</p><p class="text-xl font-bold ${colorClass}">${value}</p></div>`
                            }).join('')}
                        </div>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                            <div>
                                <h3 class="text-xl font-semibold mb-2">Skill History</h3>
                                <div class="h-64"><canvas id="elo-chart"></canvas></div>
                            </div>
                            <div>
                                <h3 class="text-xl font-semibold mb-2">Recent Matches</h3>
                                <div id="player-match-history" class="space-y-2 max-h-64 overflow-y-auto pr-2">${recentMatchesHtml}</div>
                            </div>
                        </div>
                    </div>`
                },
                playerMatchHistoryRow: (match, matchId, won, skillChange, currentPlayer) => {
                    const highlightName = (team, name) => team.map(p => p === name ? `<strong class="text-violet-300 font-bold">${name}</strong>` : p).join(', ');
                    const teamAString = highlightName(match.teamA, currentPlayer);
                    const teamBString = highlightName(match.teamB, currentPlayer);
                    return `<div data-match-id="${matchId}" class="bg-slate-800/50 p-3 rounded-md flex justify-between items-center hover:bg-slate-800/80 cursor-pointer transition">
                        <div>
                            <p class="text-sm font-semibold">${teamAString} vs ${teamBString}</p>
                            <p class="text-xs text-muted-color">Week ${match.week} &middot; ${new Date(match.ts).toLocaleDateString()}</p>
                        </div>
                        <div class="text-right">
                            <p class="font-bold text-lg">${match.scoreA}-${match.scoreB}</p>
                            <div class="flex items-center justify-end gap-2">
                                <span class="text-xs font-bold ${won ? 'text-green-400' : 'text-red-400'}">${won ? 'WIN' : 'LOSS'}</span>
                                <span class="text-xs font-semibold ${skillChange >= 0 ? 'text-green-400' : 'text-red-400'}">${skillChange >= 0 ? '+' : ''}${skillChange.toFixed(2)}</span>
                            </div>
                        </div>
                    </div>`
                },
                matchModal: (match, teamAChanges, teamBChanges, winProbA, matchId) => {
                    const renderTeam = changes => changes.map(p => `
                        <li class="flex justify-between items-center py-2">
                            <div>
                                <a href="#" data-player-name="${p.name}" class="font-semibold hover:underline">${p.name}</a>
                                <p class="text-xs text-muted-color">Pre-match Skill: ${p.preSkill}</p>
                            </div>
                            <div class="text-right">
                                <span class="font-bold text-lg ${parseFloat(p.change) > 0 ? 'text-green-400' : parseFloat(p.change) < 0 ? 'text-red-400' : ''}">${p.change}</span>
                                <p class="text-xs text-muted-color">New Skill: ${p.postSkill}</p>
                            </div>
                        </li>`).join('');
                    const matchDate = new Date(match.ts);
                    const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                    return `
                        <div class="flex justify-between items-start mb-4">
                             <div><h2 class="text-2xl font-bold">Match #${parseInt(matchId) + 1}</h2><p class="text-sm text-muted-color">${matchDate.toLocaleDateString(undefined, dateOptions)}</p></div>
                            <button class="close-modal-btn text-muted-color hover:text-color"><i data-lucide="x" class="h-6 w-6"></i></button>
                        </div>
                        <div class="text-center mb-6"><p class="font-extrabold text-5xl">${match.scoreA} - ${match.scoreB}</p></div>
                        <div class="glass-card p-4 mb-6">
                             <h3 class="font-bold text-center mb-1">Pre-Match Prediction</h3>
                             <p class="text-xs text-slate-500 text-center mb-2">Based on player skills before this match.</p>
                             <div class="flex justify-around items-center">
                                <div class="text-center"><p class="font-bold text-xl">Team A</p><p class="text-2xl font-bold text-sky-400">${(winProbA * 100).toFixed(1)}%</p></div>
                                <div class="text-slate-500 font-bold text-lg">vs</div>
                                <div class="text-center"><p class="font-bold text-xl">Team B</p><p class="text-2xl font-bold text-sky-400">${((1 - winProbA) * 100).toFixed(1)}%</p></div>
                             </div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">${[teamAChanges, teamBChanges].map((changes, i) => `<div class="bg-slate-800/50 p-4 rounded-lg"><h3 class="font-bold text-center mb-2">Team ${i === 0 ? 'A' : 'B'} Skill Changes</h3><ul class="divide-y divide-slate-700/50">${renderTeam(changes)}</ul></div>`).join('')}</div>`;
                },
                editPlayerModal: (playerName, details) => `<form id="edit-player-form"><div class="flex justify-between items-center mb-4"><h2 class="text-2xl font-bold">Edit Player</h2><button type="button" class="close-modal-btn text-muted-color hover:text-color"><i data-lucide="x" class="h-6 w-6"></i></button></div><div class="space-y-4"><div><label class="block text-sm font-medium">Name</label><input type="text" name="newName" value="${playerName}" class="mt-1 w-full rounded-md bg-slate-800/50 border-slate-600 p-2 border"></div><div><label class="block text-sm font-medium">Last Name</label><input type="text" name="lastName" value="${details.lastName || ''}" class="mt-1 w-full rounded-md bg-slate-800/50 border-slate-600 p-2 border"></div><div><label class="block text-sm font-medium">Abbreviation</label><input type="text" name="abbrev" value="${details.abbrev || ''}" maxlength="3" class="mt-1 w-full rounded-md bg-slate-800/50 border-slate-600 p-2 border"></div><div><label class="block text-sm font-medium">Number</label><input type="text" name="number" value="${details.number || ''}" class="mt-1 w-full rounded-md bg-slate-800/50 border-slate-600 p-2 border"></div></div><div class="mt-6 flex justify-end gap-3"><button type="button" class="close-modal-btn glass-button rounded-md py-2 px-4 font-semibold">Cancel</button><button type="submit" class="bg-violet-600 text-white rounded-md py-2 px-4 font-semibold hover:bg-violet-700 transition">Save Changes</button></div><p id="edit-player-error" class="text-red-400 text-right text-sm font-semibold h-4 mt-2"></p></form>`
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            app.init();
        });
    </script>
</body>
</html>



